<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<event category="STEP" id="0">
  <actions>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">grav = gravity * global.tickfactor;
/* run gravity */
vspeed += grav;

/* first, run limits */
speed = min(speed, maxVelocity);
speed *= global.tickfactor;

/* run movement and collision checks */
var iters, iterspace, spent, olddx, olddy, oldx, oldy;
slopesize = 6;
iters = ceil(speed);
iterspace = speed;
spent = 0;
olddx = hspeed;
olddy = vspeed;
oldx = x;
oldy = y;

while(spent &lt; iterspace and speed != 0)
{
    itersize = (iterspace-spent)/ceil((iterspace-spent));
    
    xd =  cos(degtorad(direction))*itersize;
    yd = -sin(degtorad(direction))*itersize;
    
    bx = string(x);
    by = string(y);
    
    if(!place_meeting(x+xd, y+yd, Obstacle))
    {
        if(!place_meeting(x+xd, y+1, Obstacle) and place_meeting(x, y+1, Obstacle) and place_meeting(x+xd, y+slopesize+1, Obstacle) and vspeed &gt;= 0)
        {
            x += xd;
            y += slopesize;
            spent += point_distance(0, 0, xd, slopesize);
            
            vspeed = min(0, vspeed);
            y = round(y);
            event_user(9);
        }
        else
        {
            x += xd;
            y += yd;
            event_user(9);
            spent += itersize;
        }
    }
    else // place_meeting(x+xd, y+yd, Obstacle) true
    {
        if(!place_meeting(x+xd, y-slopesize, Obstacle) and abs(xd) &gt;= abs(yd))
        {
            x += xd;
            y -= slopesize;
            spent += point_distance(0, 0, xd, -slopesize);
            
            vspeed = min(0, vspeed);
            y = round(y);
            event_user(9);
        }
        else if(!place_meeting(x+xd, y+slopesize, Obstacle) and abs(xd) &gt;= abs(yd))
        {
            x += xd;
            y += slopesize;
            spent += point_distance(0, 0, xd, slopesize);
            
            vspeed = max(0, vspeed);
            y = round(y);
            event_user(9);
        }
        else if(!place_meeting(x+xd, y, Obstacle))
        {
            x += xd;
            spent += abs(xd);
            
            vspeed = 0;
            event_user(9);
            
            oldspace = iterspace;
            iterspace = point_distance(0, oldy, olddx, y);
            y = round(y);
        }
        else if(!place_meeting(x, y+yd, Obstacle))
        {
            y += yd;
            spent += abs(yd);
            
            hspeed = 0;
            event_user(9);
            
            oldspace = iterspace;
            iterspace = point_distance(oldx, 0, x, olddy);
            x = round(x);
        }
        else //I've never seen this happen, I don't know if it's possible. Consider it a fallback.
        {
            x = round(x);
            y = round(y);
            speed = 0;
            event_user(9);
        }
    }
}
speed /= global.tickfactor;

/* this is only here for code execution order reasons (apparently? I'm guessing) */
if(global.run_absticks)
    timeUnscathed = min(timeUnscathed+1, 10*30);

/* cleanup */
x -= hspeed;
y -= vspeed;
vspeed -= gravity;
</argument>
      </arguments>
    </action>
  </actions>
</event>
